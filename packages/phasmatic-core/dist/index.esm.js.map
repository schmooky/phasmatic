{"version":3,"file":"index.esm.js","sources":["../src/types.ts","../src/errors.ts","../src/timer.ts","../src/stateMachine.ts","../src/decorators.ts","../src/flowchart.ts"],"sourcesContent":["/**\r\n * Simple handler function\r\n */\r\nexport type SimpleHandler = () => void;\r\n\r\n/**\r\n * Function that adds a disposer to be called when phase ends\r\n */\r\nexport type PhaseDisposerType = (disposer: SimpleHandler) => void;\r\n\r\n/**\r\n * Function that sets a timeout within the current phase\r\n */\r\nexport type PhaseTimeoutType = (seconds: number, handler: SimpleHandler) => void;\r\n\r\n/**\r\n * Context passed to each phase handler\r\n */\r\nexport interface PhaseContext<T = any> {\r\n  /** The context/store object */\r\n  context: T;\r\n  \r\n  /** Add a disposer that will be called when exiting this phase */\r\n  addDisposer: PhaseDisposerType;\r\n  \r\n  /** Set a timeout that will be cleared if the phase ends before it triggers */\r\n  setTimeout: PhaseTimeoutType;\r\n  \r\n  /** Current phase name */\r\n  currentPhase: string;\r\n}\r\n\r\n/**\r\n * Phase handler function signature\r\n * Return type is generic because it needs to be constrained in the decorator\r\n */\r\nexport type PhaseHandler<TContext, TReturn> = (\r\n  context: PhaseContext<TContext>\r\n) => TReturn | Promise<TReturn>;\r\n\r\n/**\r\n * Metadata for a registered phase\r\n */\r\nexport interface PhaseMetadata<TContext> {\r\n  name: string;\r\n  handler: PhaseHandler<TContext, any>;\r\n  possibleNextPhases: string[];\r\n}\r\n\r\n/**\r\n * Static registry key used on StateMachine instances\r\n */\r\nexport const PHASE_REGISTRY = Symbol('PHASE_REGISTRY');\r\n\r\n/**\r\n * Error types specific to Phasmatic\r\n */\r\nexport enum PhasmaticErrorType {\r\n  INVALID_PHASE = 'INVALID_PHASE',\r\n  PHASE_EXECUTION_ERROR = 'PHASE_EXECUTION_ERROR',\r\n  INVALID_TRANSITION = 'INVALID_TRANSITION',\r\n  SELF_TRANSITION = 'SELF_TRANSITION',\r\n}","/**\r\n * Base error class for Phasmatic errors\r\n */\r\nexport class PhasmaticError extends Error {\r\n    constructor(message: string) {\r\n      super(message);\r\n      this.name = 'PhasmaticError';\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Error thrown when a phase tries to transition to itself\r\n   */\r\n  export class PhasmaticSelfTransitionError extends PhasmaticError {\r\n    constructor(message: string) {\r\n      super(message);\r\n      this.name = 'PhasmaticSelfTransitionError';\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Error thrown when a transition to an invalid phase is attempted\r\n   */\r\n  export class PhasmaticInvalidTransitionError extends PhasmaticError {\r\n    constructor(message: string) {\r\n      super(message);\r\n      this.name = 'PhasmaticInvalidTransitionError';\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Error thrown when a phase execution fails\r\n   */\r\n  export class PhasmaticExecutionError extends PhasmaticError {\r\n    constructor(message: string, public originalError: Error) {\r\n      super(message);\r\n      this.name = 'PhasmaticExecutionError';\r\n    }\r\n  }","/**\r\n * Timer manager for handling phase timeouts\r\n */\r\nexport class TimerManager {\r\n    private timers: Map<string, number> = new Map();\r\n    \r\n    /**\r\n     * Creates a timeout that can be cleared\r\n     */\r\n    setTimeout(id: string, callback: () => void, timeoutMs: number): void {\r\n      // Clear any existing timeout with this ID\r\n      this.clearTimeout(id);\r\n      \r\n      // Create a new timeout\r\n      const timerId = window.setTimeout(() => {\r\n        this.timers.delete(id);\r\n        callback();\r\n      }, timeoutMs) as unknown as number;\r\n      \r\n      // Store the timer ID\r\n      this.timers.set(id, timerId);\r\n    }\r\n    \r\n    /**\r\n     * Clears a specific timeout\r\n     */\r\n    clearTimeout(id: string): void {\r\n      const timerId = this.timers.get(id);\r\n      if (timerId !== undefined) {\r\n        window.clearTimeout(timerId);\r\n        this.timers.delete(id);\r\n      }\r\n    }\r\n    \r\n    /**\r\n     * Clears all timeouts\r\n     */\r\n    clearAll(): void {\r\n      this.timers.forEach((timerId) => {\r\n        window.clearTimeout(timerId);\r\n      });\r\n      this.timers.clear();\r\n    }\r\n  }","import { makeObservable, observable, action, makeAutoObservable } from 'mobx';\r\nimport { \r\n  PHASE_REGISTRY, \r\n  PhaseContext, \r\n  PhaseDisposerType, \r\n  PhaseHandler, \r\n  PhaseMetadata, \r\n  PhaseTimeoutType, \r\n  SimpleHandler \r\n} from './types';\r\nimport { \r\n  PhasmaticError, \r\n  PhasmaticExecutionError, \r\n  PhasmaticInvalidTransitionError \r\n} from './errors';\r\nimport { TimerManager } from './timer';\r\n\r\n/**\r\n * Base StateMachine class\r\n * TPhase is a union type of all possible phase names (usually an enum)\r\n */\r\nexport abstract class StateMachine<TPhase extends string, TContext = any> {\r\n  /** Current active phase */\r\n  public currentPhase: TPhase | null = null;\r\n  \r\n  /** Whether the machine is running */\r\n  public isRunning: boolean = false;\r\n  \r\n  /** Whether to output debug information */\r\n  protected debug: boolean;\r\n  \r\n  /** Function to call on errors */\r\n  protected errorHandler?: (error: Error) => void;\r\n  \r\n  /** Initial phase to start with */\r\n  private initialPhase: TPhase;\r\n  \r\n  /** Phase context that will be passed to handlers */\r\n  private context: TContext;\r\n  \r\n  /** Timer manager for handling timeouts */\r\n  private timerManager = new TimerManager();\r\n  \r\n  /** List of disposers for the current phase */\r\n  private phaseDisposers: SimpleHandler[] = [];\r\n  \r\n  /** Registry of phase handlers */\r\n  private phaseRegistry: Map<string, PhaseMetadata<TContext>>;\r\n  \r\n  /**\r\n * Creates a new state machine\r\n * @param context The context object to pass to phase handlers\r\n * @param initialPhase The phase to start with\r\n * @param debug Whether to output debug information\r\n * @param errorHandler Optional error handler\r\n */\r\nconstructor(\r\n  context: TContext,\r\n  initialPhase: TPhase,\r\n  debug: boolean = false,\r\n  errorHandler?: (error: Error) => void\r\n) {\r\n  this.context = context;\r\n  this.initialPhase = initialPhase;\r\n  this.debug = debug;\r\n  this.errorHandler = errorHandler;\r\n  \r\n  // Get the phase registry from the constructor\r\n  this.phaseRegistry = (this.constructor as any)[PHASE_REGISTRY] || new Map();\r\n  \r\n  // Make observable properties\r\n  makeAutoObservable(this);\r\n}\r\n  \r\n  /**\r\n   * Starts the state machine\r\n   */\r\n  public start(): void {\r\n    if (this.isRunning) {\r\n      this.log('State machine is already running');\r\n      return;\r\n    }\r\n    \r\n    this.isRunning = true;\r\n    this.transitionTo(this.initialPhase);\r\n  }\r\n  \r\n  /**\r\n   * Stops the state machine\r\n   */\r\n  public stop(): void {\r\n    if (!this.isRunning) {\r\n      return;\r\n    }\r\n    \r\n    this.isRunning = false;\r\n    this.disposeCurrentPhase();\r\n    this.currentPhase = null;\r\n  }\r\n  \r\n  /**\r\n   * Resets the state machine back to the initial phase\r\n   */\r\n  public reset(): void {\r\n    const wasRunning = this.isRunning;\r\n    this.stop();\r\n    \r\n    if (wasRunning) {\r\n      this.start();\r\n    }\r\n  }\r\n  \r\n/**\r\n * Sets the current phase without executing its handler\r\n * @param phase The phase to set\r\n */\r\nprotected setPhase(phase: TPhase | null): void {\r\n  this.currentPhase = phase;\r\n}\r\n  \r\n  /**\r\n   * Transitions to a new phase and executes its handler\r\n   * @param phase The phase to transition to\r\n   */\r\n  protected transitionTo(phase: TPhase): void {\r\n    if (!this.isRunning) {\r\n      throw new PhasmaticError('Cannot transition when state machine is not running');\r\n    }\r\n    \r\n    // Make sure the phase exists\r\n    if (!this.phaseRegistry.has(phase)) {\r\n      throw new PhasmaticInvalidTransitionError(`Phase \"${phase}\" does not exist`);\r\n    }\r\n    \r\n    // Log the transition\r\n    this.log(`Transitioning to phase: ${phase}`);\r\n    \r\n    // Clean up the current phase\r\n    this.disposeCurrentPhase();\r\n    \r\n    // Set the new phase\r\n    this.setPhase(phase);\r\n    \r\n    // Execute the new phase handler\r\n    this.executePhase(phase);\r\n  }\r\n  \r\n  /**\r\n   * Executes the handler for the given phase\r\n   * @param phase The phase to execute\r\n   */\r\n  private async executePhase(phase: TPhase): Promise<void> {\r\n    const phaseMetadata = this.phaseRegistry.get(phase);\r\n    if (!phaseMetadata) {\r\n      throw new PhasmaticInvalidTransitionError(`Phase \"${phase}\" does not exist`);\r\n    }\r\n    \r\n    // Create the context for this phase\r\n    const phaseContext: PhaseContext<TContext> = {\r\n      context: this.context,\r\n      addDisposer: this.addPhaseDisposer.bind(this),\r\n      setTimeout: this.phaseTimeout.bind(this),\r\n      currentPhase: phase\r\n    };\r\n    \r\n    try {\r\n      // Execute the phase handler\r\n      const result = phaseMetadata.handler.call(this, phaseContext);\r\n      let nextPhase: string;\r\n      \r\n      // Handle synchronous and asynchronous results\r\n      if (result instanceof Promise) {\r\n        nextPhase = await result;\r\n      } else {\r\n        nextPhase = result;\r\n      }\r\n      \r\n      // Validate the next phase\r\n      this.validateTransition(phase, nextPhase);\r\n      \r\n      // Transition to the next phase\r\n      this.transitionTo(nextPhase as TPhase);\r\n    } catch (error) {\r\n      this.handleError(error);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Adds a disposer function that will be called when the current phase ends\r\n   * @param disposer The disposer function\r\n   */\r\n  private addPhaseDisposer(disposer: SimpleHandler): void {\r\n    this.phaseDisposers.push(disposer);\r\n  }\r\n  \r\n  /**\r\n   * Sets a timeout for the current phase\r\n   * @param seconds The number of seconds to wait\r\n   * @param handler The function to call when the timeout expires\r\n   */\r\n  private phaseTimeout(seconds: number, handler: SimpleHandler): void {\r\n    const timeoutId = `timeout_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\r\n    \r\n    // Create a timeout\r\n    this.timerManager.setTimeout(timeoutId, handler, seconds * 1000);\r\n    \r\n    // Add a disposer to clear the timeout when the phase ends\r\n    this.addPhaseDisposer(() => {\r\n      this.timerManager.clearTimeout(timeoutId);\r\n    });\r\n  }\r\n  \r\n  /**\r\n   * Disposes the current phase by calling all disposers\r\n   */\r\n  private disposeCurrentPhase(): void {\r\n    // Clear all timeouts\r\n    this.timerManager.clearAll();\r\n    \r\n    // Call all disposers in reverse order (LIFO)\r\n    while (this.phaseDisposers.length > 0) {\r\n      const disposer = this.phaseDisposers.pop();\r\n      if (disposer) {\r\n        try {\r\n          disposer();\r\n        } catch (error) {\r\n          this.log(`Error in disposer: ${error}`);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Validates that a transition is allowed\r\n   * @param fromPhase The phase transitioning from\r\n   * @param toPhase The phase transitioning to\r\n   */\r\n  private validateTransition(fromPhase: string, toPhase: string): void {\r\n    // Get the metadata for the current phase\r\n    const fromPhaseMetadata = this.phaseRegistry.get(fromPhase);\r\n    if (!fromPhaseMetadata) {\r\n      throw new PhasmaticInvalidTransitionError(`Phase \"${fromPhase}\" does not exist`);\r\n    }\r\n    \r\n    // Make sure the transition is allowed\r\n    if (!fromPhaseMetadata.possibleNextPhases.includes(toPhase)) {\r\n      throw new PhasmaticInvalidTransitionError(\r\n        `Invalid transition from \"${fromPhase}\" to \"${toPhase}\". ` +\r\n        `Allowed next phases are: ${fromPhaseMetadata.possibleNextPhases.join(', ')}`\r\n      );\r\n    }\r\n    \r\n    // Make sure the target phase exists\r\n    if (!this.phaseRegistry.has(toPhase)) {\r\n      throw new PhasmaticInvalidTransitionError(`Target phase \"${toPhase}\" does not exist`);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Handles an error that occurred during phase execution\r\n   * @param error The error that occurred\r\n   */\r\n  private handleError(error: any): void {\r\n    // Wrap the error\r\n    const wrappedError = new PhasmaticExecutionError(\r\n      `Error executing phase \"${this.currentPhase}\": ${error.message}`,\r\n      error\r\n    );\r\n    \r\n    // Log the error\r\n    this.log(`Error: ${wrappedError.message}`);\r\n    \r\n    // Call the error handler if it exists\r\n    if (this.errorHandler) {\r\n      this.errorHandler(wrappedError);\r\n    } else {\r\n      // Otherwise, re-throw the error\r\n      throw wrappedError;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Logs a message if debug is enabled\r\n   * @param message The message to log\r\n   */\r\n  private log(message: string): void {\r\n    if (this.debug) {\r\n      console.log(`[Phasmatic] ${message}`);\r\n    }\r\n  }\r\n}","import 'reflect-metadata';\r\nimport { PHASE_REGISTRY, PhaseHandler, PhaseMetadata } from './types';\r\nimport { PhasmaticSelfTransitionError } from './errors';\r\n\r\n/**\r\n * Phase decorator - registers a method as a state handler\r\n * @param phaseName The name of the phase this method handles\r\n */\r\nexport function Phase<T extends string>(phaseName: T) {\r\n  return function(\r\n    target: any,\r\n    propertyKey: string,\r\n    descriptor: PropertyDescriptor\r\n  ) {\r\n    // Get the return type from the method's metadata\r\n    const returnType = Reflect.getMetadata('design:returntype', target, propertyKey);\r\n    \r\n    // Extract possible next phases from the return type\r\n    // This uses TypeScript's built-in type system\r\n    const possibleNextPhases: string[] = extractPossibleNextPhases(returnType);\r\n    \r\n    // Ensure the phase can't transition to itself\r\n    if (possibleNextPhases.includes(phaseName)) {\r\n      throw new PhasmaticSelfTransitionError(\r\n        `Phase ${phaseName} cannot transition to itself. This would create an infinite loop.`\r\n      );\r\n    }\r\n\r\n    // Get or create the registry on the class prototype\r\n    if (!target.constructor[PHASE_REGISTRY]) {\r\n      target.constructor[PHASE_REGISTRY] = new Map<string, PhaseMetadata<any>>();\r\n    }\r\n    \r\n    // Add this phase to the registry\r\n    target.constructor[PHASE_REGISTRY].set(phaseName, {\r\n      name: phaseName,\r\n      handler: descriptor.value,\r\n      possibleNextPhases\r\n    });\r\n    \r\n    return descriptor;\r\n  };\r\n}\r\n\r\n/**\r\n * Extract possible next phases from a TypeScript return type\r\n * This is a helper that works with the TypeScript compiler API\r\n */\r\nfunction extractPossibleNextPhases(returnType: any): string[] {\r\n  // For Promise<T> types, we extract the T\r\n  if (returnType?.name === 'Promise') {\r\n    const typeArgs = Reflect.getMetadata('design:paramtypes', returnType);\r\n    if (typeArgs && typeArgs.length > 0) {\r\n      return extractPossibleNextPhases(typeArgs[0]);\r\n    }\r\n  }\r\n  \r\n  // For union types (T1 | T2 | T3)\r\n  if (returnType?.types) {\r\n    return returnType.types.flatMap(extractPossibleNextPhases);\r\n  }\r\n  \r\n  // For literal types (string literals)\r\n  if (typeof returnType === 'string') {\r\n    return [returnType];\r\n  }\r\n  \r\n  // For enum values \r\n  if (typeof returnType === 'object' && returnType !== null) {\r\n    return Object.values(returnType);\r\n  }\r\n  \r\n  return [];\r\n}","import { PHASE_REGISTRY, PhaseMetadata } from './types';\r\n\r\n/**\r\n * Generates a Mermaid flowchart string from a state machine class\r\n * @param stateMachineClass The state machine class to generate a flowchart for\r\n * @returns A Mermaid flowchart string\r\n */\r\nexport function generateFlowchart<T extends string>(\r\n  stateMachineClass: any\r\n): string {\r\n  // Get the phase registry\r\n  const phaseRegistry: Map<string, PhaseMetadata<any>> = stateMachineClass[PHASE_REGISTRY];\r\n  if (!phaseRegistry) {\r\n    throw new Error('No phase registry found. Make sure you have decorated your phase methods with @Phase.');\r\n  }\r\n  \r\n  // Build the flowchart\r\n  let flowchart = 'stateDiagram-v2\\n';\r\n  \r\n  // Add state transitions\r\n  phaseRegistry.forEach((metadata, phaseName) => {\r\n    metadata.possibleNextPhases.forEach(nextPhase => {\r\n      flowchart += `    ${phaseName} --> ${nextPhase}\\n`;\r\n    });\r\n  });\r\n  \r\n  return flowchart;\r\n}"],"names":[],"mappings":"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"}